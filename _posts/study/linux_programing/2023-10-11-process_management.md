---
layout: single
title: Process Management
toc_label: Process Management
categories: Linux
tags: [Linux, Uni]
author_profile: false
search: true
use_tex: false
---

> 프로세스 매니지먼트

<br>

## Programs, Process Threads 의 정의


### Programs
- 하드디스크에 적재된 실행 가능한 코드
- 컴파일 된 실행 가능한 코드.
- 디스크와 같은 저장 메체에 위치

<br>

### Process
- 실행중인 프로그램.
- 바이너리 이미지, 메모리 적재가 되어있음
- 가상의 메모리 인스턴스, 커널 리소스, 스레드를 포함

<br>

### Thread
- 프로세스 내부에서 활동중인 유닛 (실제로 작업을 수행하는 코드)
- 스레드는 프로그램(프로세스) 내에서 실행되는 독립적인 흐름으로, 멀티스레딩 환경에서 여러 스레드가 동시에 실행될 수 있다.
- 각 스레드는 자체 "가상화된 프로세서"를 가지고 있는데, 이는 스레드가 독립적으로 실행 상태를 관리하고, 자신만의 스택, 레지스터, 명령 포인터 등을 가지고 있음을 의미 
- 이러한 특성 덕분에 스레드는 병렬 처리와 동시성을 가능
- 하나의 프로세스 내에 여러개의 스레드가 존재할 수 있다.
- 메모리의 가상화는 프로세스와 연관되어 있기 때문에, 모든 스레드는 동일한 메모리 주소 공간을 공유한다.

<br>

## The Process ID


### Definition
- PID 는 각 프로세스를 대표하는 고유 식별자이다.
- 운영 체제는 이 번호를 사용하여 프로세스를 관리하고, 사용자와 다른 시스템 프로세스는 이 번호를 사용하여 특정 프로세스를 참조한다.
  - 한 시점에 각 PID 는 고유합니다. 즉, 시스템 상에서 동시에 두 개 이상의 프로세스가 동일한 PID 를 가질 수 없다. 
  - 프로세스가 종료되면, 그 프로세스의 PID 는 재사용될 수 있다.

<br>

### The idle process
- 이는 시스템에서 항상 실행 중인 특별한 프로세스로, 다른 실행 가능한 프로세스가 없을 때 커널이 실행하는 프로세스
- 아이들 프로세스는 항상 PID 0을 가지고 있다. 
- 이 프로세스는 시스템이 다른 작업을 수행할 것이 없을 때 실행되며, 일반적으로 시스템의 CPU 사용 시간을 최소화하는 데 사용한다.

<br>

### The init process
- he First Process Executed by the Kernel: init 프로세스는 시스템이 부팅된 후 커널이 처음으로 실행하는 프로세스이다.
- 이는 시스템의 모든 다른 프로세스의 부모 프로세스로 간주되며, PID 1을 가진다.
- Kernel’s Decision on the init Process: 
  - 사용자가 커널에게 명시적으로 어떤 프로세스를 실행할 것인지 지시하지 않는 한(예: init 커널 명령줄 매개변수를 통해), 커널은 스스로 적절한 init 프로세스를 식별해야 한다.
- 

<br>

### Process ID Allocation
- 커널은 프로세스에게 PID 를 할당하며, 이전 프로세스가 죽더라도 순차적으로 번호를 지정한다.
- <span style='color:#fff9ff'>커널은 최상단에서 감싸지 않는 한 프로세스 ID 값을 재사용하지 않는다. 즉, /proc/sys/kernel/pid_max 에 있는 값이 할당될 때까지 이전 값들은 재사용되지 않는다.</span>
  - i.e., 프로세스에 PID 를 순차적으로 할당하고, 최대 허용 PID 까지 도달하면 다시 처음부터 시작하되, 최대값에 도달하기 전까지는 이전에 사용했던 PID 를 재사용하지 않는다.

<br>

### The Process Hierarchy
#### 부모-자식 관계:
- 프로세스는 '부모'와 '자식'의 관계를 가진다.
- 모든 프로세스(초기 init 프로세스 제외)는 다른 프로세스로부터 생성되며, 이에 따라 부모-자식 관계가 형성된다.
- 이러한 관계는 부모 프로세스 ID(ppid)에 기록되며, 이는 자식 프로세스가 부모 프로세스를 식별할 수 있게 한다.

<br>

#### 사용자와 그룹 소유권:
- 각 프로세스는 특정 사용자와 그룹에 속한다.
- 이 소유권은 프로세스가 시스템 리소스에 접근하는 권한을 제어하는 데 사용된다.
- 자식 프로세스는 부모 프로세스의 사용자와 그룹 소유권을 상속받는다.

<br>

#### 프로세스 그룹:
- 프로세스는 프로세스 그룹의 일원이다.
- 프로세스 그룹은 사용자/그룹 개념과는 별개이다.
- 자식 프로세스는 일반적으로 부모와 동일한 프로세스 그룹에 속한다.
- 셸이 파이프라인을 생성하면, 파이프라인의 모든 명령은 동일한 프로세스 그룹에 속한다.
- 프로세스 그룹은 그룹 내의 모든 프로세스에게 신호를 보내거나 정보를 얻는 것을 용이하게 한다.

<br>

#### 요약:
- 프로세스 계층 구조는 부모-자식 관계와 사용자/그룹 소유권, 프로세스의 개념을 포함한다. 
- 부모 프로세스는 자식 프로세스를 생성하고, 자식 프로세스는 부모의 소유권과  <span style='color:orange'>그룹 소유권을 상속</span>받는다. 
- 프로세스 그룹은 관련 프로세스들을 묶어 신호 전송이나 정보 추출을 쉽게 만들어준다.

<br>

### pid_t
- 프로세스 ID를 표현하는 데 사용되는 데이터 타입이다.
- pid_t 는 <sys/types.h> 헤더 파일에 정의된다.
- c 표준은 아니나, 리눅스에서는 일반적으로 int 타입이다.
- getpid() 를 사용해 실행중인 프로세스의 pid 를 얻을 수 있다.
- getppid() 를 사용해 실행중인 프로세스의 부모 pid 를 얻을 수 있다.

<br>

## Running a New Process


### Executing a Program
- 프로세스는 cpu 자원을 할당받고, i/o 상태이거나 유휴상태일 때 자원을 반납. 준비상태가 되면 다시 자원을 할당받아 프로세스 실행한다.
- 하나의 시스템 호출을 사용하여 바이너르 프로그램을 메모리에 로드하며, 주소 공간의 이전 내용을 대체하고 새 프로그램의 실행을 시작한다.
- 이를 새 프로그램을 실행한다고 하며, 이 기능은 exec 함수 계열로 제공된다.

<br>

### Creating a New Process
- A near-duplication its parent process (거의 복제하는 것)
  - 부모프로세스의 영역을 카피해서 프로세스를 생성하니 시간이 오래걸린다!
  - 그래서, 자식프로세스는 부모 프로세스에 접근 권한을 부여하여 효율성 증대
    - 메모리를 공유한다. 프로그램 카운터만 변경 (각자의 실행 위치를 나타내는 프로그램 카운터만 다름!)
  - 그러다 실제로 복사할 때도 있다: 
    - 프로세스가 공유중인 메모리를 수정해야 할 때.
    - Copy-On-Write (이하 설명)
  - 새 프로세스를 생성하는 행위를 포킹(forking)이라고 하며, 이 기능은 fork() 시스템 호출로 제공
    - fork(새 프로세스 생성) - exec(새 바이너리 로드)

<br>

### Exec Family of Calls

<img width="720" alt="image" src="https://github.com/woo-kyu/woo-kyu.github.io/assets/102133610/e2b4122d-9f9a-46e7-9939-bf76e6d4ea31">{: .align-center}

<br>

#### execl
- execl 함수는 프로그램의 새로운 엔트리 포인트(시작점)로 점프하여, 호출이 성공하면 그 프로세스의 주소 공간에서 방금 실행된 코드는 더이상 존재하지 않는다.
  - execl을 호출하면 현재 프로세스의 메모리 주소 공간에 새 프로그램의 코드와 데이터가 로드된다.
  - 이 과정에서 원래 프로세스의 코드와 데이터는 완전히 사라지게 된다.
  - 이로 인해, execl이 성공적으로 호출된 후에는 원래 프로그램의 어떠한 코드도 더 이상 실행되지 않는다. 
  - 대신 새로운 프로그램의 엔트리 포인트(시작점)에서 실행이 시작된다. 
  - i.e., execl 함수가 단순히 새 프로그램을 실행시키는 것이 아니라 현재 프로세스의 내용을 새 프로그램의 내용으로 완전히 교체한다는 것을 의미한다.
  - 이 동작은 프로세스의 생성 비용을 절약하면서도 다른 프로그램을 실행할 수 있게 해준다.
  - e.g., 쉘 프로그램에서 사용자가 새로운 명령을 입력하면, 쉘은 fork 시스템 호출을 사용하여 자식 프로세스를 생성한 다음, 
  - 이 자식 프로세스 내에서 execl 또는 관련 함수를 사용하여 사용자가 원하는 프로그램을 실행시킬 수 있다. 
  - 이렇게 되면, 쉘 자체는 계속 실행되면서 사용자의 명령을 기다리는 동안, 자식 프로세스는 새로운 프로그램으로 대체되어 그 프로그램을 실행하게 된다.
- 변화가 발생하는 것들:
  - 주소 공간과 프로세스 이미지: execl 호출이 성공하면 현재 프로세스의 주소 공간은 새로운 프로그램의 주소 공간으로 완전히 대체된다. 
    - 이는 현재 실행 중인 프로그램의 코드, 데이터, 힙, 스택 등이 새 프로그램의 것들로 바뀐다는 것을 의미한다.
  - 대기 중인 신호 및 포착된 신호: 실행 중인 프로세스에 대기 중인 신호나 프로세스가 이미 잡아낸 신호는 exec 호출 후 사라진다.
  - 메모리 잠금: 현재 프로세스에서 설정한 메모리 잠금이 해제된다.
  - 스레드 속성: 만약 현재 프로세스가 멀티스레드로 실행되고 있다면, 그 스레드와 관련된 모든 속성과 데이터가 사라진다.. 새로운 프로그램은 단일 스레드로 시작된다.
  - 정적 변수: 현재 프로세스의 정적 변수는 모두 초기화되거나 사라진다.
  - 메모리 주소 공간과 관련된 모든 것: 이는 메모리에 매핑된 파일, 공유 메모리 세그먼트, 힙, 스택 등 현재 프로세스의 메모리 구조와 관련된 모든 것을 포함한다.
  - 사용자 공간에서의 존재: atexit()와 같은 C 라이브러리의 특정 기능은 프로세스의 사용자 공간에서만 존재하므로, 이들도 모두 초기화된다.

- 변화가 발생하지 않는 것들:
- pid, 부모의 pid, 우선순위, 소유 사용자 및 그룹: exec 호출이 성공하더라도, 이러한 프로세스의 기본 속성은 변경되지 않는다. 
  - i.e., 프로세스 ID나 부모 프로세스의 ID, 우선순위 등은 그대로 유지된다.
- 열린 파일의 상속: execl 호출 후에도 현재 프로세스에서 열린 파일은 그대로 유지된다. 
  - 새로운 프로그램이 그 파일을 계속 사용할 수 있도록 하기 위해서.
  - 보안상 문제가 될 수 있기 때문에 주의가 필요하다. 
  - 특정 파일이나 리소스에 접근할 수 있는 권한을 가진 프로세스가 다른 프로그램으로 대체되면, 그 새 프로그램도 같은 권한을 가지게 된다.

<img width="600" alt="image" src="https://github.com/woo-kyu/woo-kyu.github.io/assets/102133610/78b908b1-383d-4924-b1d3-6d7c7266a452">{: .align-center}

<br>

#### execv
- 성공 시:
  - 시스템 호출들은 반환하지 않는다.
  - 호출이 성공하면 현재 프로세스의 메모리 이미지가 새로운 프로그램의 이미지로 완전히 대체되기 때문
- 실패 시:
  - -1 반환

#### exec errno
- E2BIG: 전달된 인자나 환경 변수의 크기가 너무 크다
- EACCES: 지정된 파일에 실행 권한이 없다
- EFAULT: 잘못된 주소가 제공
- ENOENT: 지정된 파일이나 경로를 찾을 수 없다
- ENOMEM: 커널에서 필요한 메모리를 할당할 수 없다
- ENOTDIR: 경로의 일부분이 디렉터리가 아니다
- ELIBBAD: ELF 인터프리터가 잘못되었다
- ETXTBSY: 실행하려는 바이너리 파일이 현재 쓰여지고 있다
- EIO: I/O 오류가 발생했다
- EINVAL: 잘못된 exec 형식을 사용했다


##### execl vs. execv
- execl:
  - execl 함수는 명시적으로 개별 인자를 전달한다. 인자의 수는 가변적 
    - e.g., execl("/bin/ls", "ls", "-l", NULL); 
  - 첫 번째 인자는 실행하려는 프로그램의 경로이다.
  - 그 이후의 인자들은 프로그램에 전달할 인자들이다.
  - 인자 리스트의 마지막에는 NULL을 포함해야 한다.
        
- execv:
  - execv 함수는 인자를 문자열 포인터의 배열로 전달한다.
  -  첫번째 인자는 실행하려는 프로그램의 경로이다. 
  - 두 번째 인자는 인자들의 배열이다. 배열의 마지막 요소는 NULL 포인터여야 한다.

<br>

### The fork() system call

- 특징
  - fork()는 현재 프로세스(부모 프로세스라고도 함)의 복사본(자식 프로세스)을 생성한다.
  - 자식 프로세스는 부모 프로세스의 메모리 이미지, 환경 변수, 파일 디스크립터 등을 상속받는다.

- fork 반환값:
  - 자식 프로세스에서: fork() 호출이 성공하면 0을 반환한다. 이를 통해 프로그래머는 현재 코드가 자식 프로세스에서 실행 중인지 확인할 수 있다. 
  - 부모 프로세스에서: fork()는 자식 프로세스의 프로세스 ID (pid)를 반환한다. 이를 통해 부모는 자식 프로세스를 추적하거나 제어할 수 있다.

  <img width="600" alt="image" src="https://github.com/woo-kyu/woo-kyu.github.io/assets/102133610/dfd88911-bc4b-4516-b9be-810a0984ab87">{: .align-center}

  <img width="720" alt="image" src="https://github.com/woo-kyu/woo-kyu.github.io/assets/102133610/3494dfda-b622-40fb-9d17-7efe5e8bf6db">{: .align-center}

#### child vs. parents process
- PID (Process ID): 부모와 자식 프로세스는 서로 다른 PID를 가진다.
- 메모리 공간: 두 프로세스는 독립적인 메모리 공간을 가진다. 
  - 부모 프로세스의 메모리 공간은 자식 프로세스에 복사되지만, 이후의 변경은 각 프로세스에서 독립적으로 이루어진다. 
  - 따라서 한 프로세스에서의 메모리 변경은 다른 프로세스에 영향을 주지 않는다.
- 파일 디스크립터: 자식 프로세스는 부모 프로세스의 파일 디스크립터를 상속받지만, 두 프로세스의 파일 디스크립터는 독립적이다. 
  - 하나의 프로세스에서 파일 디스크립터를 닫아도 다른 프로세스에는 영향을 주지 않는다.
- 프로세스 상태: 자식 프로세스는 부모 프로세스의 상태나 우선순위, 신호 마스크 등을 상속받는다. 그러나 이후의 변경은 각 프로세스에서 독립적으로 처리된다.
- 자원 사용 제한: 자식은 부모의 자원 사용 제한을 상속받는다.
- 이런 차이점에도 불구하고, fork() 호출 직후에는 자식 프로세스가 부모 프로세스의 거의 정확한 복사본으로 시작한다.

<br>

#### Orphan vs. Zombie (고아 vs. 좀비)

- 고아 프로세스 (Orphan Process):
  - 부모 프로세스가 종료되고 자식 프로세스가 아직 실행 중인 경우, 그 자식 프로세스는 고아 프로세스가 됩니다. 
  - 고아 프로세스는 init 프로세스 (PID 1)에 의해 '입양'됩니다. 즉, init 프로세스가 새로운 부모 프로세스가 되어 자식 프로세스를 관리하게 됩니다. 
  - init 프로세스는 주기적으로 자식 프로세스의 상태를 확인하며, 종료된 자식 프로세스의 종료 상태를 회수하여 좀비 프로세스가 되지 않게 합니다. 

- 좀비 프로세스 (Zombie Process):
  - 프로세스가 종료되면 그 정보는 여전히 프로세스 테이블에 남아 있습니다. 이 때, 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 않으면, 자식 프로세스는 종료되었지만 프로세스 테이블에서는 여전히 정보가 남아있게 되어 "좀비" 상태가 됩니다.
  - 좀비 프로세스는 CPU 자원을 사용하지 않지만, 프로세스 테이블에는 여전히 항목으로 남아 있기 때문에 리소스를 소비합니다.
  - 부모 프로세스가 wait() 또는 waitpid()와 같은 시스템 호출을 사용하여 자식 프로세스의 상태를 회수하면, 좀비 프로세스는 완전히 시스템에서 제거됩니다.
  - 만약 부모 프로세스가 자식의 상태를 회수하지 않는다면, init 프로세스가 그 자식 프로세스를 '입양'하고 해당 상태를 회수하여 좀비 프로세스를 제거합니다.

- 요약:
  - 고아 프로세스는 부모가 먼저 종료된 후에도 실행 중인 프로세스입니다.
  - 좀비 프로세스는 종료되었지만 그 상태가 아직 부모 프로세스에 의해 회수되지 않아 시스템에 남아 있는 프로세스입니다.

### Copy-On-Write




<br>

### vfork()
- 복사하는 과정이 너무 길어서
- 부모와 자식이 메모리를 공유
- to share parent's resources
- 자식 프로세스의 프로그램 카운터(pid)만 생성.
  - 부모 프로세스를 복사하면 어차피 같으니!
- 프로그램 카운터만 생성해 전달
- 부모프로세스는 자식 프로세스가 실행 될 때, 모든 정보를 기록, 자식에게 양보 (자식이 먼저 실행 후 종료하면, 기록된 정보를 불러오기)
  - 공유되는 변수에 대해 rase condition 방지
  - execv 를 사용하면?
    - Copy onwrite 사용

<br>

### Copy-on-Write
- vfork에서, 자식 프로세스가 부모프로세스에 write 할 때,
- 자식 프로세스는 그제서야 데이터를 복사.
- 아주 게을러 (p임): lazy optimization

<br>

프로세스가 종료되는 때
- 정상적으로 종료
- 다른 프로세스에 의해 수동적으로 종료
- 운영체제에 의해 종료 (rap of kernel)

